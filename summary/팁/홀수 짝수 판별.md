# 홀수 짝수 판별

2로 나누었을때 나머지가 0인 수가 짝수라는 의미는 같습니다.

다만, `i % 2 == 0`에서 `%` 모듈러 연산은 속도가 느립니다.

조금이라도 더 빠르게 어떻게든 속도를 높이고 싶을때

모듈러 연산대신에 비트 연산 `&`를 사용합니다. 

### 의외다 파이썬은 모듈러 연산이 더 빠르다... 더 확인해봐야겠다.


# 코드
### 1) python
```
1. % 모듈러 연산  5.112352132797241
2. & 비트 연산  5.803492546081543
```
```python
import time

# 0. init
count = 100000000 # 1억

# 1. % 모듈러 연산
mod_start_time = time.time()
for i in range(count):
    if i % 2 == 1: pass # 홀수
    else: pass # 짝수
print("1. % 모듈러 연산 ", time.time() - mod_start_time)

# 2. % 비트 연산
bit_start_time = time.time()
for i in range(count):
    if i & 1 == 1: pass # 홀수
    else: pass # 짝수
print("2. & 비트 연산 ", time.time() - bit_start_time)
```

### 2) java
```
1. % 모듈러 연산 3307600
2. & 비트 연산 2059800
```
```java
class Main {
    public static void main(String[] args) {
        // 0. init
        int COUNT = 100000000; // 1억

        // 1. % 모듈러 연산
        long modStartTime = System.nanoTime();
        
        for(int i=0; i<COUNT; i++) {
            if((i % 2) == 1); // 홀수
            else; // 짝수
        }
        System.out.println("1. % 모듈러 연산 " + (System.nanoTime() - modStartTime));

        // 2. & 비트 연산
        long bitStartTime = System.nanoTime();

        for(int i=0; i<COUNT; i++) {
            if((i & 1) == 1); // 홀수
            else; // 짝수
        }
        System.out.println("2. & 비트 연산 " + (System.nanoTime() - bitStartTime));
    }
}
```
